#
# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
from typing import Callable, Generic, Optional, TypeVar

import anyio

__all__ = ["AsyncSendTracker", "dummy_tracker"]

_Result = TypeVar("_Result")


class AsyncSendTracker(Generic[_Result]):
    """Synchronization utility for coordinating deferred data generation and sending operations.

    This class is designed for protocols following a sans-IO model (e.g., hyper-h2),
    where data generation is separated from actual I/O operations. It provides a way
    to coordinate between data generation, transmission, and completion tracking.

    The tracker supports both blocking and non-blocking modes. In blocking mode,
    callers must explicitly call complete() after data transmission. In non-blocking
    mode (no_wait=True), the tracker completes immediately after triggering.

    Example:
        tracker = AsyncSendTracker(lambda: h2_conn.send_headers(...))

        # In send loop:
        tracker.trigger()  # Generate the data.
        data = h2_conn.data_to_send()  # Extract generated data.
        await transport.send(data)  # Send over the wire.
        tracker.complete()  # Mark as complete.

        # In waiting code:
        result = await tracker.result()  # Wait for completion
    """

    __slots__ = ("_event", "_result", "_exc", "_send_func", "_no_wait")

    _event: anyio.Event
    _result: Optional[_Result]
    _exc: Optional[Exception]
    _send_func: Callable[[], _Result]
    _no_wait: bool

    def __init__(self, send_func: Callable[[], _Result], no_wait: bool = False) -> None:
        """Initialize the tracker with a data generation function.

        Args:
            send_func: A callable that generates the data to be sent.
            no_wait: If True, the tracker completes immediately after triggering,
                    without waiting for explicit completion.
        """
        self._event = anyio.Event()
        self._result = None
        self._exc = None
        self._send_func = send_func
        self._no_wait = no_wait

    def trigger(self) -> None:
        """Execute the data generation function.

        This method calls the send_func provided during initialization. If an
        exception occurs during execution, it is captured and stored. For no_wait
        trackers or when an exception occurs, the tracker is marked complete.
        """
        try:
            self._result = self._send_func()
        except Exception as e:
            self._exc = e
        finally:
            # Complete immediately if no_wait is True or an exception occurred
            if self._no_wait or self._exc:
                self._event.set()

    def complete(self, exc: Optional[Exception] = None) -> None:
        """Mark the tracker as complete.

        This method should be called after the generated data has been successfully
        transmitted. It signals completion to any awaiting result() calls.

        Args:
            exc: An optional exception to store. If provided, result() will raise
                this exception instead of returning the generated data.

        Note:
            This method can only complete the tracker once. Subsequent calls
            are ignored to prevent race conditions.
        """
        if not self._event.is_set():
            if exc is not None:
                self._exc = exc
            self._event.set()

    async def result(self) -> Optional[_Result]:
        """Wait for completion and return the generated result.

        This method blocks until the tracker is completed via complete() or
        auto-completion (for no_wait trackers).

        Returns:
            The data generated by the send_func.

        Raises:
            Exception: If send_func raised an exception or complete() was called
                      with an exception.
        """
        await self._event.wait()
        if self._exc:
            raise self._exc
        return self._result

    async def exception(self) -> Optional[Exception]:
        """Wait for completion and return any stored exception.

        This method is useful for checking if an operation failed without
        raising the exception.

        Returns:
            The stored exception if any occurred, otherwise None.
        """
        await self._event.wait()
        return self._exc


# Pre-configured tracker that completes immediately and returns None
dummy_tracker = AsyncSendTracker(lambda: None, no_wait=True)
